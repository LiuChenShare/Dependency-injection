//2017-8-18  18:10
	C#依赖注入那些事儿（二）		来源：(http://blog.csdn.net/CommandBaby/article/details/51578699)



 //2017-8-18  18:10

	ConsoleApp2_1	
		这个项目描述的是“Setter注入”，学习完之后我对依赖注入的理解就是：
			假设我有一把手枪，只能打R口径的子弹。现在有A子弹和B子弹都制作成R口径，所以我需要A子弹的时候就把A子弹装进手枪，需要B子弹的时候就把B子弹装进手枪，而不需要因为换子弹而去换枪，加入C子弹的时候也只需要把C子弹也做成R口径即可。
		
		Tip：OCP原则，即开放关闭原则，指设计应该对扩展开放，对修改关闭。


 //2017-11-08  10:10

	ConsoleApp2_2	
		这个项目描述的是“构造注入”，构造注入与Setting注入很类似，只是注入点由Setter方法变成了构造方法。这里要注意，由于构造注入只能在实例化客户类时注入一次，所以一点注入，程序运行期间是没法改变一个客户类对象内的服务类实例的。


 //2017-11-08  10:35

	ConsoleApp2_3	
		这个项目描述的是“依赖获取”
		上面学习的注入方式，都是客户类被动接受所依赖的服务类，这也符合“注入”这个词。
		依赖获取是指在系统中提供一个获取点，客户类依然依赖服务类的接口。当客户类需要服务类时，从获取点主动去的指定的服务类，具体的服务类类型由获取点的配置决定。


 //2017-11-08  16:00

	ConsoleApp2_4	
		这个项目描述的是“反射与依赖注入”。
		是对上一个“依赖获取”的补充和扩展升级
		例3的“依赖获取”使用了多态性和Abstract Factory，但对OCP贯彻的不够彻底。
		在上面的例子中我们假设组件只有三种，不会增加新的组件，但是可能出现新的外观系统，
		如需要加一套Ubuntu风格的组件，我们可以新增UbuntuWindow、UbuntuButton、UbuntuTextBox和UbuntuFactory，并分别实现相应接口，
		这是符合OCP的，因为这是扩展。
		但我们除了修改配置文件，还要无可避免的修改FactoryContainer，需要加一个分支条件，这个地方破坏了OCP。
		所以我们假设这样一种方法，我们将类的名字作为配置项，就可以实现在不修改代码的情况下，加载未来才会出现的类。
		于是我们舍弃了FactoryContainer，使用一个反射工厂ReflectionFactory。
